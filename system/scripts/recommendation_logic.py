from llm import LLM
from models import TagCount
from movie_plot_finder import MoviePlotFinder
from prompt_manager import PromptManager
from recommender import Recommender


class RecommendationLogic:
    def __init__(self, llm_name, ease_model_path, ratings_path, movie_names_path, movie_plots_path):
        self.recommender = Recommender(ratings_path=ratings_path, movie_names_path=movie_names_path)
        self.recommender.fit(model_path=ease_model_path)
        self.plot_finder = MoviePlotFinder(file_path=movie_plots_path)
        self.llm = LLM(model=llm_name)
        
        use_instruction_prompts = llm_name == "mistral" or llm_name == "mixtral"
        self.prompt_manager = PromptManager(use_instruction_prompts=use_instruction_prompts)


    def weighted_geometric_avg(self, a, b, weight_a, weight_b):
        return (a**weight_a * b**weight_b)**(1 / (weight_a + weight_b))
    
    
    """ --------------- LLM BASED RECOMMENDATIONS --------------- """

    def get_rs_recomms(self, movie_ratings, k_):
        """ Get recommendations from the RS model
        Args:
            movie_ratings (list): list of tuples (movie_id, rating)
            k_ (int): number of recommendations to return
        Returns:
            list: list of tuples (item_id, imdb_id, title, score)
        """
        predictions = self.recommender.predict(movie_ratings, k=k_)
        titles = predictions.title.to_list()
        scores = [round(score, 2) for score in predictions.score.to_list()]
        imdb_ids = predictions.imdbId.to_list()
        item_ids = predictions.item_id.to_list()
        return list(zip(item_ids, imdb_ids, titles, scores))

    def get_movie_plot_fitness(self, user_preferences, plot):
        """ Get the fitness of a movie plot to a user's genaral preferences
        Args:
            user_preferences (str): user's general preferences
            plot (str): movie plot
        Returns:
            tuple: (score, explanation) where score is a float between 0 and 5 and explanation is a string
        """

        fitness_prompt = self.prompt_manager.get_plot_fitness_prompt(user_preferences, plot)
        answer = self.llm.generate(fitness_prompt)
        
        try:
            score, explanation = float(answer.split("---")[0].strip()), answer.split("---")[1].strip()
        except ValueError:
            score, explanation = 3, "ERROR: Failed to parse the answer."
        return score, explanation
    
    def normalise_scores(self, results):
        """ Normalises total_scores to be between 0 and 10, with the highest score being 10
        Args:
            results (list): list of dictionaries
        Returns:
            list: list of dictionaries with normalised scores
        """
        max_score = max(result['total_score'] for result in results)
        for result in results:
            result['total_score'] = round(result['total_score'] / max_score * 10, 2)
        return results

    def get_recomms(self, llm_answer, user_ratings, rs_importance, k=10):
        """ Get recommendations using a combination of the RS model and the LLM model
        Args:
            llm_answer (str): The answer generated by the LLM model, containing movie ratings and general preferences in the form <movie_name>: <rating>;;;<movie_name>: <rating>---<general_preferences>
            user_ratings (list): list of tuples (movie_id, rating)
            rs_importance (int): importance of the RS model in the final score. LLM importance will be 100 - rs_importance
            k (int, optional): Number of recommendations to return. Defaults to 10.
        Returns:
            list: list of dictionaries containing the recommendations
        """
        llm_importance = 100 - rs_importance
        use_llm = llm_importance > 0
        use_rs = rs_importance > 0
        
        prompt_ratings, user_preferences = self.llm.split_llm_answer(llm_answer)
        if prompt_ratings:
            prompt_ratings_ids = self.recommender.convert_movie_names_to_ids(prompt_ratings)
            user_ratings.extend(prompt_ratings_ids)
        
        if not use_rs:
            user_ratings = []       # Empty user_ratings will make recommender return random movies
        
        
        
        print("\n", "-"*50)
        print("Prompt ratings and user preferences:")
        print(user_ratings, user_preferences)
        print("-"*50, "\n")
        
        # return user_ratings       #! Comment this out

        rs_recomms = self.get_rs_recomms(user_ratings, k)

        if user_preferences is None or not use_llm:
            explanation = "Only RS recommendations used." if not use_llm else "No general preferences found in user's prompt."
            results = [{'item_id': item_id, 'imdb_id': imdb_id, 'title': title, 'total_score': score, 'rs_score': score, 'llm_score': None, 'explanation': explanation} for item_id, imdb_id, title, score in rs_recomms]
            
            results = self.normalise_scores(results)
            return sorted(results, key=lambda x: x['total_score'], reverse=True)          

        results = []
        for item_id, imdb_id, movie_title, rs_score in rs_recomms:
            plot = self.plot_finder.find_plot(item_id)
            if plot:
                llm_score, explanation = self.get_movie_plot_fitness(user_preferences, plot)
                total_score = self.weighted_geometric_avg(rs_score, llm_score, rs_importance / 100, llm_importance / 100)
                results.append({'item_id': item_id, "imdb_id": imdb_id, "title": movie_title, "total_score": total_score, "rs_score": rs_score, "llm_score": llm_score, "explanation": explanation})
            else:
                # total score will assume llm score of 3
                total_score = self.weighted_geometric_avg(rs_score, 3, rs_importance / 100, llm_importance / 100)
                results.append({'item_id': item_id, "imdb_id": imdb_id, "title": movie_title, "total_score": total_score, "rs_score": rs_score, "llm_score": None, "explanation": "Movie plot not found."})
                
        results = self.normalise_scores(results)
        return sorted(results, key=lambda x: x['total_score'], reverse=True)

    def get_llm_recommendations(self, user_prompt, user_ratings, rs_importance, k=10):
        model_prompt = self.prompt_manager.get_extraction_prompt(user_prompt)
        answer = self.llm.generate(model_prompt)
        
        print()
        print(user_prompt)
        print(answer)
        print()

        # return self.get_recomms(answer, user_ratings, rs_importance, k)

        recommendations = self.get_recomms(answer, user_ratings, rs_importance, k)
        return {"answer": answer, "recommendations": recommendations}
    
    
    
    
    
    """ --------------- TAG BASED RECOMMENDATIONS --------------- """
    
    def rank_movie_with_tags(self, movie_id, user_tags):
        """ Rank how well a movie matches a user's tags. The score is calculated by the sum of the number of occurrences of the user's tags in the movie's tags divided by the total number of tags for the movie.
        Args:
            movie_id (int): ID of the movie
            user_tags (list): list of tag ids
        Returns:
            float: score between 0 and 1
        """
        tag_counts = TagCount.query.filter_by(item_id=movie_id).order_by(TagCount.num.desc()).all()
        if sum(tag_count.num for tag_count in tag_counts) == 0:
            return 0    # no tags for this movie
        
        score = 0
        for user_tag in user_tags:
            for tag_count in tag_counts:
                if user_tag == tag_count.tag_id:
                    score += tag_count.num
                    break
                
        total_tag_count = sum(tag_count.num for tag_count in tag_counts)
        return round(score / total_tag_count, 3)
    
    def rank_movies_with_tags(self, movies, user_tags, ignore_tags, rs_importance):
        """ Rank movies based on how well they match a user's tags
        Args:
            movies (DataFrame): DataFrame containing columns 'item_id', 'primary_score'
            user_tags (list): list of tag ids
            ignore_tags (bool): if True, only primary_score (RS score) will be used
            rs_importance (int): importance of the RS score in the final score
        Returns:
            DataFrame: DataFrame with columns 'item_id', 'primary_score', 'secondary_score', 'combined_score'
        """
        if ignore_tags:
            movies['combined_score'] = movies['primary_score']
            movies['secondary_score'] = None
            return movies


        movies['secondary_score'] = movies['item_id'].apply(lambda movie_id: self.rank_movie_with_tags(movie_id, user_tags))
        movies['combined_score'] = movies.apply(lambda row: self.weighted_geometric_avg(row['primary_score'], row['secondary_score'], rs_importance / 100, 1 - rs_importance / 100), axis=1)

        movies.sort_values('combined_score', ascending=False, inplace=True)
        return movies
    
    def normalise_combined_score(self, df):
        """ Normalises the combined_score to be between 0 and 10, with the highest score being 10 """
        df['combined_score'] = df['combined_score'] / df['combined_score'].max() * 10
        df['combined_score'] = df['combined_score'].round(2)
        return df
    
    def get_tag_recommendations(self, user_ratings, user_tags, rs_importance, k=10):
        """ Get recommendations based on user's tags
        Args:
            user_ratings (list): list of tuples (movie_id, rating)
            user_tags (list): list of tag ids
            rs_importance (int): importance of the RS score in the final score
            k (int, optional): number of recommendations to return. Defaults to 10.
        Returns:
            DataFrame: DataFrame with columns 'item_id', 'primary_score', 'secondary_score', 'combined_score'
        """
        ignore_rs = len(user_ratings) == 0 or rs_importance == 0
        ignore_tags = len(user_tags) == 0 or rs_importance == 100

        if ignore_rs:
            user_ratings = []  # If user_ratings are empty, recommender will recommend movies at random

        recommendations = self.recommender.predict(user_ratings, k)
        recommendations['score'] = recommendations['score'].round(3)
        recommendations.rename(columns={'score': 'primary_score', 'imdbId': 'imdb_id'}, inplace=True)

        recommendations = self.rank_movies_with_tags(recommendations, user_tags, ignore_tags, rs_importance)
        recommendations = self.normalise_combined_score(recommendations)

        return recommendations